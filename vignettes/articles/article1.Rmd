---
title: "Guide to sfislands package"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo = TRUE, 
  message = FALSE, 
  warning = FALSE,
  comment = "#>"
)
```

```{r setup, include = FALSE}

library(sfislands)

```

```{r, echo=FALSE}

## Data and packages

# Read in data and necessary packages.

# required packages
packages <- c(
  "tidyverse",
  "sf",
  "mgcv",
  "ggpubr",
  "spdep",
  "sfdep",
  "here",
  "parlitools"
)

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE, quietly = TRUE))

```

```{r, echo=FALSE}

### UK data

# prepare the data
# extract and join census and election data from parlitools package
census_11 <- parlitools::census_11 |> 
  select(-constituency_name,-constituency_type,-pano, -region, -country)
bes_2019 <- parlitools::bes_2019

elect_results <- left_join(bes_2019,census_11, by=c("ons_const_id"))

# download constituency boundaries for 2019 using the st_read() command below
# they come from: https://geoportal.statistics.gov.uk/datasets/ons::wpc-dec-2019-ultra-generalised-clipped-boundaries-uk
# which results in file: WPC_Dec_2019_UGCB_UK_2022_-5406762260244410508.geojson

uk_map_download <- st_read(
  "https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/WPC_Dec_2019_UGCB_UK_2022/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson",
  quiet = TRUE)

# only need the boundaries and the IDs for merging with parlitools data
uk<- uk_map_download |> 
  select(pcon19cd,geometry) |> 
  st_transform(crs=27700) |> 
  st_make_valid() # ensure valid line overlaps etc

# create dataframe for filtering-out speaker constituencies below
speakers <- data.frame(
  year = c(2017,2019),
  constituency_name = c("Buckingham","Chorley")
)

# join constituency polygons to parlitools data
# filter out Scotland and Northern Ireland
# filter out the speakers' constituencies
# calculate the desired explanatory variables
# make levels into factors for use with `mgcv`

df <- elect_results |> 
  left_join(uk, by=c("ons_const_id"="pcon19cd")) |> 
  # filter(!country %in% c("Scotland","Northern Ireland")) |> 
  filter(!country %in% c("Northern Ireland")) |> 
  # filter(!constituency_name %in% speakers$constituency_name) |>
  mutate(degree_educated = qual_level_4,
         health_not_good = health_fair + health_bad + health_very_bad,
         white = ethnicity_white,
         con_change = con_19 - con_17, # difference in %
         lab_change = lab_19 - lab_17,
         con_swing = (con_change - lab_change)/2, # Butler swing
         region = factor(ifelse(county == "Merseyside", "Merseyside", region)),
         county = factor(county)) |> 
  st_as_sf()

# give the empty speaker seats the mean value, just for demostration purposes here
df$con_swing[df$constituency_name %in% speakers$constituency_name] <- mean(df$con_swing,na.rm = TRUE)

# create region boundaries layer for mapping
regions <- df |> group_by(region) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

# create county boundaries layer for mapping
counties <- df |> group_by(county) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

# create outline layer for mapping
uk_outline <- df |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

# filter out required independent variables and scale them
# then add back to the features which were not scaled
df_scaled <- df |> 
  st_drop_geometry() |> 
  select(degree_educated,
         health_not_good,
         white) |> 
  scale() |> 
  as.data.frame() |> 
  mutate(con_swing = df$con_swing,
         population = df$population,
         region = factor(df$region),
         county = factor(df$county),
         constituency_name = df$constituency_name)

# create a simple features (spatial) version of this with a geometry column
df_scaled_sf <- df_scaled |> 
  mutate(geometry = df$geometry) |> 
  st_as_sf() |> 
  st_transform(crs=27700)
```

## In brief

The goal of `sfislands` is to make it easier to deal with geographic datasets which contain islands. It does so using a tidy framework in the spirit of Josiah Parry's [sfdep](https://sfdep.josiahparry.com/) package.

-   These do not have to be "literal" islands but any situation where discontiguous geographical units are present.

Such a situation can lead to two issues.

-   Firstly, if unaddressed, the presence of such islands or exclaves can make certain types of contiguity-based modelling impossible.

-   Secondly, just because two areas are separated by, say, a body of water, this does not necessarily mean that they are to be considered independent of each other.

This package offers solutions to allow for the inclusion or exclusion of these units within an uncomplicated workflow.

### Installation

You can install the development version of `sfislands` from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("horankev/sfislands")
```

### Summary of features

1.  The initial setting up neighbourhood structures can be frustrating for people who are eager to get started with fitting spatial models. This is especially so when the presence of discontiguities within a geographical dataset means that, even having set up a neighbours list, the model will still not run without further awkward data manipulations.

2.  As an aid to setting up neighbourhood structures, particularly when islands are involved, the package has a function to quickly map any neighbourhood structure for visual inspection. This can also be used to examine the output of `sfdep` neighbour functions. Such maps can be used to check if the structure makes sense, given the researcher's knowledge about the geography of the study area.

3.  If there are some neighbours assigned which are not appropriate, or if you wish to add additional ones, there are functions to allow this to be done in a straightforward and openly reportable way.

4.  Once an appropriate neighbourhood structure is in place, different types of statistical tests and models can be performed. `sfdep` contains functionality to perform such test, and the output from `sfislands` can be used in its functions.

5.  The contiguity outputs from `sfislands` can be directly used to fit different types of (multilevel) (I)CAR models using, for example, the `mgcv`, `brms`, `stan` or `INLA` packages.

6.  For `mgcv` in particular, the predictions of such models can be quite tedious to extract and visualise. `sfislands` can streamline this workflow from the human side. Furthermore, there is a function to draw maps of these predictions for quick inspection.

## Functions overview

The following is a framework within which the `sfislands` functions could be used:

### Step 1: Set up data ("*pre-functions*")

| function:               | purpose:                                                                                                                                   |
|------------|-----------------------------------------------|
| **st_bridges()**        | *Create a neighbours list, matrix, or `sf` dataframe containing a neighbours list or matrix as column "nb", while accounting for islands.* |
| **st_quickmap_nb()**    | *Check contiguities visually on map.*                                                                                                      |
| **st_check_islands()**  | *Check assignment of island contiguities in a dataframe.*                                                                                  |
| **st_manual_join_nb()** | *Make manual changes to any connections.*                                                                                                  |
| **st_manual_cut_nb()**  | *Make manual changes to any connections.*                                                                                                  |

### Step 2: Create model

*Use the output of **st_bridges()** as both the data and neighbourhood inputs for a model using, for example, `mgcv`, `brms` or `inla`.*

### Step 3: Examine output ("*post functions*")

| function:               | purpose:                                                 |
|-----------------|-------------------------------------------------------|
| **st_augment()**        | *Augment the original dataframe with model predictions.* |
| **st_quickmap_preds()** | *Generate quick maps of these predictions.*              |

```{r, echo=FALSE}
## Code for functions
```

```{r, echo=FALSE}

st_bridges <- function(df, # sf dataframe
                      geom_col_name,
                      remove_islands = FALSE,
                      link_islands_k = 1, # link island to k nearest units, 0 removes all islands
                      nb_structure = "list",
                      add_to_dataframe = TRUE)
{
  
  if (!inherits(df,"sf")) {
    stop("Error: This function requires a simple features dataframe as input")
  }
  
  if (remove_islands == TRUE){
    # unconnected units
    cont <-  df |>
      sf::st_intersects()
    still_unconnected <- lengths(lapply(cont, function(x) x))
    unconnected <- which(still_unconnected == 1)
    
    df <- df[-unconnected,]
    link_islands_k = 0
    
  }
  
  if (link_islands_k > 0)
  {
    # unconnected units
    cont <-  df |>
      sf::st_intersects()
    still_unconnected <- lengths(lapply(cont, function(x) x))
    unconnected <- which(still_unconnected == 1)
    # Calculate distances
    distdf <- data.frame(
      constnumb = 0,
      ndist = 0
    )
    for (i in 1:length(unconnected))
    {
      distances <- sf::st_distance(df$geometry[unconnected[i]], sf::st_geometry(df$geometry)) |>
        as.numeric() |> sort()
      # distdf[i,2] <- round(distances[link_islands_k+1]) +100
      distdf[i,2] <- distances[link_islands_k+1] * 1.001
      distdf[i,1] <- unconnected[i]
    }
    bufs <- rep(0,nrow(df))
    for (i in 1:length(unconnected))
    {
      bufs[distdf[i,1]] <- distdf[i,2]
    }
    
    cont <- df |>
      sf::st_buffer(dist=bufs) |>
      sf::st_intersects() |>
      purrr::imap(~setdiff(.x,.y))
    
    names(cont) <- df |> dplyr::pull({{ geom_col_name }})
    
    class(cont) <- c("nb","list")
  }
  
  # otherwise, just return unaltered contiguity structure
  if(link_islands_k <= 0)
  {
    cont <- df |>
      sf::st_intersects() |>
      purrr::imap(~setdiff(.x,.y))
    
    names(cont) <- df |> dplyr::pull({{ geom_col_name }})
    
    class(cont) <- c("nb","list")
  }
  
  if(add_to_dataframe == FALSE){
    if(nb_structure == "list"){
      return(cont)
    }
    if(nb_structure =="matrix"){
      cont2 <- spdep::nb2mat(cont, style="B")
      rownames(cont2) <- names(cont)
      return(cont2)
    }
  }
  
  if(add_to_dataframe == TRUE){
    if(nb_structure == "list"){
      tempdf <- df |> 
        mutate(nb = cont)
      tempdf[[geom_col_name]] <- factor(tempdf[[geom_col_name]])
      return(tempdf)
    }
    if(nb_structure =="matrix"){
      cont2 <- spdep::nb2mat(cont, style="B")
      rownames(cont2) <- names(cont)
      tempdf <- df |> 
        mutate(nb = cont2)
      tempdf[[geom_col_name]] <- factor(tempdf[[geom_col_name]])
      return(tempdf)
    }
  }
}


```

```{r, echo=FALSE}

st_quickmap_nb <- function(nbsf,
                                linkcol = "dodgerblue", 
                                bordercol = "gray7", 
                                pointcol="darkred", 
                                fillcol = "gray95", 
                                linksize=0.2, 
                                bordersize=0.1, 
                                pointsize=0.8,
                                title=NULL,
                                subtitle=NULL){
  
  if (!inherits(nbsf,"sf")) {
    stop("Error: This function requires a simple features dataframe as input")
  }
  
  if (is.data.frame(nbsf) && !("nb" %in% colnames(nbsf))) {
    stop("Error: The dataframe must contain a column called 'nb'")
  } 
  
  if (!(is.list(nbsf$nb) || is.matrix(nbsf$nb))) {
    stop("Error: The 'nb' argument must be a neighbours list or a neighbours matrix")
  }
  
  
  # to show the contiguities on a map
  ### REMOVE THIS FOLLOWING SECTION
  # g <- g |> dplyr::group_by(department) |> dplyr::summarise()
  ###
  # first, the dataframe must be a spdf, spatial dataframe
  df_sp <- sf::as_Spatial(nbsf)
  
  if(is.matrix(nbsf$nb)){
    temp <- spdep::mat2listw(nbsf$nb, style="B")
    cont <- temp[2]
    cont <- cont$neighbours
    class(cont) <- c("nb","list")
  }
  
  if(is.list(nbsf$nb)){
    cont <- nbsf$nb
    class(cont) <- c("nb","list")
  }
  # make lines where there are contiguities
  neighbors_sf <- as(spdep::nb2lines(cont, coords = df_sp), 'sf')
  neighbors_sf <- sf::st_set_crs(neighbors_sf, sf::st_crs(nbsf))
  
  # get the endpoints of these lines (they are not necessarily the centroids...)
  endpoints_coords <- sf::st_coordinates(neighbors_sf) |> data.frame() |>
    sf::st_as_sf(coords=c("X","Y"), crs=sf::st_crs(neighbors_sf))
  
  # map the connections
  # plot <- 
    ggplot2::ggplot() +
    ggplot2::geom_sf(data=nbsf, fill=fillcol, colour=bordercol, linewidth=bordersize) +
    ggplot2::geom_sf(data = neighbors_sf, colour=linkcol, linewidth=linksize) +
    ggplot2::geom_sf(data=endpoints_coords, size=pointsize, colour=pointcol) +
    ggplot2::coord_sf(datum=NA) +
    ggplot2::labs(title = title,
                  subtitle = subtitle) + 
    ggplot2::theme_void() +
    ggplot2::theme(axis.title.x = ggplot2::element_blank()) +
    ggplot2::theme(axis.title.y = ggplot2::element_blank())
  
  # print(plot)
}

```

```{r, echo=FALSE}

st_check_islands <- function(data){
  
  if (is.data.frame(data) && !("nb" %in% colnames(data))) {
    stop("Error: The dataframe must contain a column called 'nb'")
  } 
  
  if (!(is.list(data$nb) || is.matrix(data$nb))) {
    stop("Error: The 'nb' argument must be a neighbours list or a neighbours matrix")
  }
  
  # make it a list if it's a matrix
  if(is.matrix(data$nb)){ # matrix within dataframe
    keep_rownames <- rownames(data$nb)
    tempnb <- spdep::mat2listw(data$nb, style="B")
    tempnb <- tempnb[2]
    data$nb <- tempnb$neighbours
    names(data$nb) <- keep_rownames
  }
  
  # unconnected units
  cont <-  data |>
    sf::st_intersects()
  still_unconnected <- lengths(lapply(cont, function(x) x))
  unconnected <- which(still_unconnected == 1)
  
  
  output <- data[unconnected,]$nb
  names(output) <- paste(names(output)," : ",unconnected)
  
  output2 <- do.call(rbind, lapply(names(output), function(x) cbind(region = x, nb_num = output[[x]]))) |> 
    data.frame()
  
  consnames <- names(data$nb)
  output2$nb_names <- consnames[as.integer(output2$nb_num)]
  
  output2 <- separate(output2, region, into = c("island_names", "island_num"), sep = " : ")
  
  return(output2)
}

```

```{r, echo=FALSE}
st_manual_join_nb <- function(nb,x,y){
  
  if (!(is.data.frame(nb) || is.list(nb$nb) || is.matrix(nb$nb) || is.list(nb) || is.matrix(nb))) {
    stop("Error: The 'nb' argument must be a neighbours list, a neighbours matrix, or a dataframe containing a neighbours list or matrix named 'nb'")
  } else if (is.data.frame(nb) && !("nb" %in% colnames(nb))) {
    stop("Error: The dataframe must contain a column called 'nb'")
  } 
  
  # MAKE INTEGERS: xnum and ynum
  
  ### case when numeric x and y:
  if(is.numeric(x) & is.numeric(y)){
    xnum <- x |> as.integer()
    ynum <- y |> as.integer()
  }else{
    
    ### case when character x and y:
    # first, make into numeric is given as character
    # depending on its structure as df, list, matrix...
    if(is.data.frame(nb)){
      if(is.list(nb$nb)){
        xnum <- which(names(nb$nb)==x) |>
          as.integer()
        ynum <- which(names(nb$nb)==y) |>
          as.integer()
      }
      if(is.matrix(nb$nb)){
        xnum <- which(rownames(nb$nb)==x) |>
          as.integer()
        ynum <- which(rownames(nb$nb)==y) |>
          as.integer()
      }
    }else{
      if(is.list(nb)){
        xnum <- which(names(nb)==x) |>
          as.integer()
        ynum <- which(names(nb)==y) |>
          as.integer()
      }
      if(is.matrix(nb)){
        xnum <- which(rownames(nb)==x) |>
          as.integer()
        ynum <- which(rownames(nb)==y) |>
          as.integer()
      }
    }
    
  }
  ##############
  
  # EXTRACT THE CONTIGUITY AS LIST FOR ALL FORMS: tempnb
  
  # for cases when dataframe provided...
  if(is.data.frame(nb)){
    tempnb <- nb$nb # list or matrix within dataframe
    
    if(is.matrix(tempnb)){ # matrix within dataframe
      tempnb <- spdep::mat2listw(tempnb, style="B")
      tempnb <- tempnb[2]
      tempnb <- tempnb$neighbours
    }
    # class(tempnb) <- c("nb","list")
  }else{
    
    # now tempnb is a nb/list
    
    # when just a matrix provided, tempnb becomes a list
    if(is.matrix(nb)){
      tempnb <- spdep::mat2listw(nb, style="B")
      tempnb <- tempnb[2]
      tempnb <- tempnb$neighbours
      # class(tempnb) <- c("nb","list")
    }
    
    # when just a list provided, it is renamed tempnb
    if(is.list(nb)){
      tempnb <- nb
      # class(tempnb) <- c("nb","list")
    }
  }
  
  ######################
  # PERFORM OPERATIONS: with tempnb and xnum and ynum
  
  # now that tempnb has been created for different circumstances...
  
  # if x and y are already neighbours, return original structure unchanged
  if(xnum %in% tempnb[[ynum]])
  {
    return(nb)
  }else # else perform alteration, creating a list called tempnb2
  {
    tempnb2 <- tempnb
    tempnb2[[xnum]] <- sort(c(tempnb[[xnum]],ynum))
    # remove a 0 which would signal an island...
    tempnb2[[xnum]] <- tempnb2[[xnum]][tempnb2[[xnum]] != 0]
    tempnb2[[ynum]] <- sort(c(tempnb[[ynum]],xnum))
    tempnb2[[ynum]] <- tempnb2[[ynum]][tempnb2[[ynum]] != 0]
    class(tempnb2) <- c("nb","list")
    
    if(is.data.frame(nb)){
      if(is.matrix(nb$nb)){
        tempmat <- spdep::nb2mat(tempnb2, style = "B")
        dfmat_return <- nb
        dfmat_return$nb <- tempmat
        return(dfmat_return)
      }
      if(is.list(nb$nb)){
        dflist_return <- nb
        dflist_return$nb <- tempnb2
        return(dflist_return)
      }
    }else{
      # return in appropriate form
      if(is.list(nb)){
        return(tempnb2)
      }
      if(is.matrix(nb)){
        tempmat <- spdep::nb2mat(tempnb2, style = "B")
        return(tempmat)
      }
    }
  }
}

```

```{r, echo=FALSE}
st_manual_cut_nb <- function(nb,x,y){
  
  if (!(is.data.frame(nb) || is.list(nb$nb) || is.matrix(nb$nb) || is.list(nb) || is.matrix(nb))) {
    stop("Error: The 'nb' argument must be a neighbours list, a neighbours matrix, or a dataframe containing a neighbours list or matrix named 'nb'")
  } else if (is.data.frame(nb) && !("nb" %in% colnames(nb))) {
    stop("Error: The dataframe must contain a column called 'nb'")
  } 
  
  ### case when numeric x and y:
  # xnum<-x |> as.integer()
  # ynum<-y |> as.integer()
  if(is.numeric(x)){xnum <- x |> as.integer()}
  if(is.numeric(y)){ynum <- y |> as.integer()}
  
  ### case when character x and y:
  # first, make into numeric is given as character
  # depending on its structure as df, list, matrix...
  if(is.character(x) & is.character(y)){
    
    if(is.data.frame(nb)){
      if(is.character(x)){
        if(is.list(nb$nb)){
          xnum <- which(names(nb$nb)==x) |>
            as.integer()
        }
        if(is.matrix(nb$nb)){
          xnum <- which(rownames(nb$nb)==x) |>
            as.integer()
        }
      }
      if(is.character(y)){
        if(is.list(nb$nb)){
          ynum <- which(names(nb$nb)==y) |>
            as.integer()
        }
        if(is.matrix(nb$nb)){
          ynum <- which(rownames(nb$nb)==y) |>
            as.integer()
        }
      }
    }else{
      if(is.list(nb)){
        xnum <- which(names(nb)==x) |>
          as.integer()
        ynum <- which(names(nb)==y) |>
          as.integer()
      }
      if(is.matrix(nb)){
        xnum <- which(rownames(nb)==x) |>
          as.integer()
        ynum <- which(rownames(nb)==y) |>
          as.integer()
      }
    }
    
  }
  
  # for cases when dataframe provided...
  if(is.data.frame(nb)){
    tempnb <- nb$nb # list or matrix within dataframe
    
    if(is.matrix(tempnb)){ # matrix within dataframe
      tempnb <- spdep::mat2listw(tempnb, style="B")
      tempnb <- tempnb[2]
      tempnb <- tempnb$neighbours
    }
    # class(tempnb) <- c("nb","list")
  }else{
    
    # now tempnb is a nb/list
    
    # when just a matrix provided, tempnb becomes a list
    if(is.matrix(nb)){
      tempnb <- spdep::mat2listw(nb, style="B")
      tempnb <- tempnb[2]
      tempnb <- tempnb$neighbours
      # class(tempnb) <- c("nb","list")
    }
    
    # when just a list provided, it is renamed tempnb
    if(is.list(nb)){
      tempnb <- nb
      # class(tempnb) <- c("nb","list")
    }
  }
  # now that tempnb has been created for different circumstances...
  
  # if x and y are already neighbours, return original structure unchanged
  if(!xnum %in% tempnb[[ynum]])
  {
    return(nb)
  }else # else perform alteration, creating a list called tempnb
  {
    tempnb2 <- tempnb
    tempnb2[[xnum]] <- tempnb[[xnum]][tempnb[[xnum]] !=ynum] |>
      sort()
    tempnb2[[ynum]] <- tempnb[[ynum]][tempnb[[ynum]] !=xnum] |>
      sort()
    
    class(tempnb2) <- c("nb","list")
    
    if(is.data.frame(nb)){
      if(is.matrix(nb$nb)){
        tempmat <- spdep::nb2mat(tempnb2, style = "B")
        dfmat_return <- nb
        dfmat_return$nb <- tempmat
        return(dfmat_return)
      }
      if(is.list(nb$nb)){
        dflist_return <- nb
        dflist_return$nb <- tempnb2
        return(dflist_return)
      }
    }else{
      # return in appropriate form
      if(is.list(nb)){
        return(tempnb2)
      }
      if(is.matrix(nb)){
        tempmat <- spdep::nb2mat(tempnb2, style = "B")
        return(tempmat)
      }
    }
  }
}

```

```{r, echo=FALSE}
st_augment <- function(model,df){
  
  if (!(class(model)[1] %in% "gam")) {
    stop("Error: This function requires the model to be of class 'gam'")
  }
  
  # Identify numeric columns
  numeric_columns <- sapply(df, is.numeric)
  
  # Replace numeric columns with the number 1
  tempdf <- df
  tempdf[, numeric_columns] <- 1
  
  output <- predict(model, tempdf, type = "terms", se.fit = TRUE) |>
    as.data.frame()
  
  ### need different process for renaming cols if one versus more than one smooth:
  
  ### if only one smooth:
  
  if(ncol(output) == 2 & nrow(summary(model$smooth)) == 1) {
    # change names from fit. to the type of effect (random effect or mrf.smooth)
    names(output)[1] <- paste0(summary(model$smooth)[,2],".")
    names(output)[stringr::str_starts(names(output),"fit.s.")] <- stringr::str_replace(names(output)[stringr::str_starts(names(output),"fit.s.")],
                                                                                       "fit.s.",
                                                                                       paste0(summary(model$smooth)[,2],"."))
    # same for standard error columns
    names(output)[2] <- paste0("se.",summary(model$smooth)[,2],".")
  }
  
  ### if more than one smooth:
  
  else {
    
    # change names from fit. to the type of effect (random effect or mrf.smooth)
    names(output)[stringr::str_starts(names(output),"fit.s.")] <- stringr::str_replace(names(output)[stringr::str_starts(names(output),"fit.s.")],
                                                                                       "fit.s.",
                                                                                       paste0(summary(model$smooth)[,2],"."))
    # same for standard error columns
    names(output)[stringr::str_starts(names(output),"se.fit.s.")] <- stringr::str_replace(names(output)[stringr::str_starts(names(output),"se.fit.s.")],
                                                                                          "se.fit.s.",
                                                                                          paste0("se.",summary(model$smooth)[,2],"."))
  }
  
  # remove the . at the end of each matching string
  names(output) <- stringr::str_remove_all(names(output), "\\.$")
  
  # swap around and put a | in the mrf smooths
  names(output) <- stringr::str_replace_all(names(output), "\\.{2}", "|")
  
  # rearrange the random.effect colnames
  names(output) <- stringr::str_replace_all(names(output), "random\\.effect\\.(.*?)\\.", "random.effect.\\1|")
  
  # swap order around the | character
  names(output) <- stringr::str_replace_all(names(output), "\\.([^.]*)\\|(.*)", ".\\2|\\1")
  
  output2 <- cbind(output,df) |>
    as.data.frame() |>
    dplyr::select(-matches("fit\\.")) |>
    dplyr::select(-(1:ncol(output)), everything()) |> 
    sf::st_as_sf()
  
  return(output2)
  
}
```

```{r, echo=FALSE}
st_quickmap_preds <- function(output){

  if (!inherits(output,"sf")) {
    stop("Error: This function requires a simple features dataframe as input")
  }
  
  output1 <- output |>
    dplyr::select(starts_with("random.effect"),starts_with("mrf.smooth"))

  fillnames <- output1 |>
    sf::st_drop_geometry() |>
    names()

  # split column names into title and subtitle
  # either side of second . in string
  newtitle <- sub("^(.*?\\..*?)\\..*$", "\\1", fillnames)
  # extract the text after random.effect. or mrf.smooth.
  newsubtitle <- str_replace_all(fillnames, "(random\\.effect\\.|mrf\\.smooth\\.)", "")

  plot_list <- list()
  for (i in 1:length(fillnames)){
    plot_list[[i]] <- ggplot2::ggplot() +
      ggplot2::geom_sf(data=output1, ggplot2::aes(fill=!!as.name(fillnames[i])), linewidth=0.05, colour="black") +
      ggplot2::scale_fill_gradient2() +
      ggplot2::labs(title=newtitle[i],
                    subtitle=newsubtitle[i]) +
      ggplot2::coord_sf(datum=NA) +
      ggplot2::theme_minimal() +
      ggplot2::theme_bw() +
      ggplot2::theme(plot.subtitle = ggplot2::element_text(size=10))

  }

  return(plot_list)
}
```

Below, we look at these functions in more detail and show them in operation.

## Pre-functions

`sfdep` offers excellent tools for building neighbourhood structures, among other things. It has a range of functions depending on how we want to define what *neighbour* should mean.

However, often when preparing areal spatial data, the presence of uncontiguous areas (such as islands or exclaves) can create difficulties. We might also want to account for some hidden contiguities by allowing bridges, tunnels etc. to render two uncontiguous areas as neighbours.

`sfislands` provides functions to make this task easier.

It also provides a number of further helper functions to examine these neighbourhood structures and use them in models such that the workflow is streamlined from the human side.

### Mainland France (`guerry` dataset)

`sfislands` is intended to be used alongside the `sfdep` package. The principal functions from `sfdep` for areal data are demonstrated in its vignette using the `guerry` ("*Essay on the Moral Statistics of France*") dataset. This data applies to the geographical area of mainland France as shown below:

```{r}
g <- guerry |> 
  st_as_sf()

ggplot(g) + 
  geom_sf() + 
  theme_void()
```

In this French example, the `st_islands` function **st_bridges()** produces exactly the same neighbourhood structure (based on contiguity) as **sfdep::st_contiguity()**. This can be seen below by piping these neighbourhood outputs through the `st_islands` function **st_quickmap_nb()** which gives a visual representation of the structure on a map. This function works with neighbourhoods constructed from any package as long as they are in list or matrix form.

For **st_quickmap_nb()**, the neighbourhoods should be within an `sf` dataframe as a column called "nb". **st_bridges()** does this automatically whereas the "nb" column needs to be added when using `sfdep` functions.

#### sfislands::st_bridges()

The `st_bridges()` contiguities below, where each department is considered a neighbour of another if it touches it at least one point...

```{r}
g |> st_bridges("department") |> 
  st_quickmap_nb()

```

... are the same as these from `sfdep`:

#### sfdep::st_contiguity()

```{r}
g |> mutate(nb = st_contiguity(geometry)) |> 
  st_quickmap_nb()

```

As these maps are produced using `ggplot2`, their characteristics can be edited using normal `ggplot2` syntax (see 1, below). For convenience, simple arguments are also provided (see 2, below) for changing the core characteristics of the map in a simple way:

```{r, fig.width=8}
ggarrange(
  
  g |> mutate(nb = st_contiguity(geometry)) |> 
    st_quickmap_nb() +
    geom_sf(data = g |> group_by(region) |> summarise(), 
            linewidth = 0.5, colour = "black", fill = NA) + 
    labs(title = "st_quickmap_nb()",
         subtitle = "1. using ggplot syntax") + 
    theme_minimal() +
    theme(panel.background = element_rect(fill = "aquamarine3", color = "black"),
          axis.text = element_blank()),
  
  g |> mutate(nb = st_contiguity(geometry)) |> 
    st_quickmap_nb(linkcol = "orange", 
                        bordercol = "white", 
                        pointcol = "yellow", 
                        fillcol = "black", 
                        linksize = 0.4, 
                        bordersize = 0.3, 
                        pointsize = 0.8,
                        title = "st_quickmap_nb()",
                        subtitle = "2. using simplified arguments"),
  
  ncol=2
)

```

`sfdep` offers a number of different types of neighbourhood structure, a selection of which are shown below. These can again be conveniently visualised using the **st_quickmap_nb()** function:

#### sfdep::st_dist_band()

All areas within a certain distance are considered neighbours:

```{r}

g |> mutate(nb = st_geometry(g) |> 
              st_dist_band(upper = 150000)) |> 
  st_quickmap_nb()

```

#### sfdep::st_knn()

The k-nearest-neighbours (here, 1) to each area are considered neighbours:

```{r}

g |> mutate(nb = st_geometry(g) |> 
              st_knn(1, symmetric = TRUE)) |> 
  st_quickmap_nb()

```

#### sfdep::st_block_nb()

All areas within a chosen block are considered neighbours:

```{r}

id <- g$code_dept
regime <- g$region
g |> 
  mutate(
    nb = st_block_nb(regime, id)
  ) |> 
  st_quickmap_nb()

```

#### sfdep::st_lag_cumul()

Cumulative higher orders of contiguity such as also including neighbours-of-neighbours:

```{r}

g |> mutate(nb = st_contiguity(geometry) |> st_nb_lag_cumul(2)) |> 
  st_quickmap_nb()

```

However, the `sfdep` functions above which rely on contiguity will run into difficulties if we consider the following geography:

### England, Scotland & Wales

In the context of the constituencies of England, Scotland and Wales, there will be problems due to the presence of islands which will not feature in a contiguity graph unless we attempt to pick out these islands and set up a buffer around them. This process is, however, cumbersome and can induce contiguities which are not intended.

One potential remedy is to entirely exclude islands from the study, another is to construct a contiguity structure according to your desired criteria and then set the islands to be contiguous to their closest *k* constituencies.

`st_bridges()` can do both of these things.

Below is the map in question:

```{r, echo=FALSE}
df_scaled_sf$country <- case_when(df_scaled_sf$region == "Wales" ~ "Wales",
                                  df_scaled_sf$region == "Scotland" ~ "Scotland",
                                  TRUE ~ "England")
```

There are island constituencies in the north around Scotland but also less obvious ones in Wales and England. The constituencies which are non-contiguous are outlined in red below:

```{r, fig.width=12, fig.height=10, echo=FALSE}
ggplot() + 
  geom_sf(data=df_scaled_sf, aes(fill=country), colour="white") + 
  # geom_sf_label(data=df_scaled_sf |> group_by(country) |> summarise(), aes(label=country),size=10) +
  geom_sf(data=df_scaled_sf |> filter(constituency_name == "Na h-Eileanan An Iar"), colour="#B20016", fill=NA, linewidth=0.7) + 
  geom_sf_label(data=df_scaled_sf |> filter(constituency_name == "Na h-Eileanan An Iar"),
                aes(label=constituency_name)) +
  geom_sf(data=df_scaled_sf |> filter(constituency_name == "Orkney and Shetland"), colour="#B20016", fill=NA, linewidth=0.7) + 
  geom_sf_label(data=df_scaled_sf |> filter(constituency_name == "Orkney and Shetland"),
                aes(label=constituency_name), nudge_x = -80000, nudge_y = -60000) +
    geom_sf(data=df_scaled_sf |> filter(constituency_name=="Ynys Mon"),colour="#B20016", fill=NA, linewidth=0.7) + 
    geom_sf_label(data=df_scaled_sf |> filter(constituency_name=="Ynys Mon"),
                  aes(label=constituency_name), nudge_x = -90000) +
    geom_sf(data=df_scaled_sf |> filter(constituency_name=="Isle Of Wight"),colour="#B20016", fill=NA, linewidth=0.7) + 
    geom_sf_label(data=df_scaled_sf |> filter(constituency_name=="Isle Of Wight"),
                  aes(label=constituency_name), nudge_x = 50000, nudge_y = -30000) +
  scale_fill_manual(values = c("antiquewhite4","#1C4769", "#24975E")) +
  # guides(fill = "none") + 
  theme_void()
```

To incorporate these we use `st_bridges()`. We can set `remove_islands` to TRUE if we decide to simply exclude the islands, or we set `link_k_islands` to the closest k constituencies to each islands which we want to bridge.

#### Remove islands

Below, with the argument `remove_islands` set to TRUE, we simply remove these islands from the dataset entirely.

```{r, fig.width=12, fig.height=10}
nbsf <- st_bridges(df = df_scaled_sf,
                  geom_col_name = "constituency_name",
                  remove_islands = T)
st_quickmap_nb(nbsf,
                     pointsize=0.05,
                    title = "st_bridges() contiguities",
                    subtitle = "no island constituencies\n(islands which remain are part of a contiguous constituency)")

```

#### Connect islands

Alternatively, we can join islands to the nearest, say, 2 constituencies. `st_bridges()` by default returns the original dataframe augmented with a "nb" column which contains the contiguities in list form.

```{r, fig.width=12, fig.height=10}
nbsf <- st_bridges(df = df_scaled_sf,
                  geom_col_name = "constituency_name",
                  link_islands_k = 2)
st_quickmap_nb(nbsf,
                     pointsize=0.05, 
                    title = "st_bridges() contiguities",
                      subtitle = "islands linked to k=2 nearest constituencies")

```

The neighbourhood structure which is created can be either a named list (the default) or a named matrix. Different modelling packages have different requirements for how this information should be presented. Furthermore, we can choose `add_to_dataframe` to be TRUE (the default) to return a dataframe with a column called `nb` which contains the named list or matrix. If FALSE, only the neighbourhood structure itself is returned

These options can be seen in the unexecuted code below:

```{r, eval=FALSE}
nbsf <- st_bridges(df = sf_dataframe,
                  geom_col_name = "the column containing the names of the contiguous areas",
                  remove_islands = T/F,
                  link_islands_k = 1...n,
                  nb_structure = "list"/"matrix",
                  add_to_dataframe = T/F,
                  title = "title",
                  subtitle = "subtitle")

```

The neighbourhoods are here in a list form:

```{r}

head(nbsf$nb)

```

But the "nb" column can also be a matrix, and `st_quickmap_nb()` will still return the same map:

```{r, fig.width=12, fig.height=10}
nbsf <- st_bridges(df = df_scaled_sf,
                  geom_col_name = "constituency_name",
                  remove_islands = F,
                  link_islands_k = 2,
                  nb_structure = "matrix",
                  add_to_dataframe = T)
st_quickmap_nb(nbsf,
                     pointsize=0.05)

```

The matrix neighbourhood structure is now of the following form:

```{r}

nbsf$nb[1:10,1:10]

```

### Editing the contiguities

There are also functions for manually changing the results of a neighbourhood construction. It may be the case that you want to add some additional links or to remove others. For example, you may be aware from local knowledge of connectivities which are not represented by mere contiguity of polygons. The presence of tunnels or bridges across a body of water would be an example of such a situation. The functions `st_manual_join_nb()` and `st_manual_cut_nb()` do this.

#### sfisland::st_check_islands()

To make the use of these functions easier and more intuitive, the function `st_check_islands()` shows us what contiguities have been set up for the islands by `st_bridges()`:

```{r}
nbsf |> st_check_islands()
```

Sometimes, as in this case, certain islands will have more than the specified k neighbours. This is due to the need for symmetry in the structure.

#### st_manual_join_nb() / st_manual_cut_nb()

Let us say we want to change some of these. For example, I will cut the tie between **Isle Of Wight** and **New Forest East** (using their numbers) and also between **Ynys Mon** and **Arfon** (using their names):

```{r}
nbsf |> 
  st_manual_cut_nb(292,378) |>
  st_manual_cut_nb("Ynys Mon","Arfon") |>
  st_check_islands()
```

As extra contiguities can be difficult to distinguish, an extreme case is shown below to demonstrate `st_manual_join_nb()`. **Gower** in South Wales is joined to **St Ives** in Cornwall and then mapped:

```{r}
st_bridges(df = df_scaled_sf|> filter(region %in% c("Wales","South West")),
           geom_col_name = "constituency_name",
           link_islands_k = 2
)  |> 
  st_manual_join_nb("Gower","St Ives") |>
  st_quickmap_nb(title = "st_bridges contiguities: Wales & South West",
                      subtitle = "with additional st_manual_join_nb() for Gower and St Ives")
```

These manual functions can also, of course, be used to edit any of the previously discussed neighbourhood structures created by `sfdep`.

For example, looking just at Scotland we can use `sfdep::st_nb_lag_cumul()` to get first and second degree neighbours:

```{r}

df_scaled_sf |> 
  filter(region == "Scotland") |> 
  mutate(nb = st_contiguity(df_scaled_sf$geometry[df_scaled_sf$region == "Scotland"]) |> 
           st_nb_lag_cumul(2)) |>  
  st_quickmap_nb()

```

This does not include the island constituencies. We can chose to include them by first using `st_bridges()` with k=2...

```{r}

df_scaled_sf |> 
  filter(region == "Scotland") |> 
  st_bridges(geom_col_name = "constituency_name",
             link_islands_k = 2) |> 
  st_quickmap_nb()

```

... and then examining the connections which have been made for islands:

```{r}

df_scaled_sf |> 
  filter(region == "Scotland") |> 
  st_bridges(geom_col_name = "constituency_name",
             link_islands_k = 2) |> 
  st_check_islands()
```

We can then add these island connections to the output of `sfdep::st_nb_lag_cumul()`:

```{r}

df_scaled_sf |> 
  filter(region == "Scotland") |> 
  mutate(nb = st_contiguity(df_scaled_sf$geometry[df_scaled_sf$region == "Scotland"]) |> 
           st_nb_lag_cumul(2)) |> 
  st_manual_join_nb(47,9) |>
  st_manual_join_nb(47,51) |>
  st_manual_join_nb(47,55) |>
  st_manual_join_nb(51,9) |>
  st_manual_join_nb(51,47) |>
  st_quickmap_nb()

```

## Modelling & post-functions

Having set up a neighbourhood structure and embedded it as a named list or matrix within the original `sf` dataset as column `nb`, there are some functions to make it easy to quickly perform ICAR smoothing, augment the original dataframe with these predictions, and visualise them.

For example, we can use the `mgcv` package to generate a Markov Random Field ICAR smooth of poor health across the study area. This is done very quickly by using `st_bridges()` to prepare the data, putting that inside the `mgcv` GAM formulation, and then piping into the `st_augment()` and `st_quickmap_preds()` functions.

```{r, fig.width=12, fig.height=10}

prep_data <- st_bridges(df_scaled_sf, "constituency_name")

gam(health_not_good ~ s(constituency_name, bs='mrf', xt=list(nb=prep_data$nb), k=100),
        data=prep_data, method="REML") |>
  st_augment(prep_data) |>
  st_quickmap_preds()

```

An equivalent model, this time smoothing over degree_educated, can be fitted using `brms`. This package requires the neighbourhoods to be in matrix form:

```{r, fig.width=12, fig.height=10}

prep_data2 <- st_bridges(df_scaled_sf, "constituency_name", nb_structure = "matrix")

# fit <- brm(degree_educated ~ car(W, gr=constituency_name, type="icar"),
#            data = prep_data2, data2 = list(W=prep_data2$nb),
#            family = gaussian(),file = "brmsfit_degree")

# fit <- readRDS("brmsfit_degree.rds")
# 
# prep_data2$brmsfit <- predict(fit,prep_data2)[,1]
# 
# ggplot(prep_data2)+geom_sf(aes(fill=brmsfit), linewidth=0.1) +
#   scale_fill_gradient2(low="firebrick4",mid="white",high="darkblue",midpoint = 0) +
#   coord_sf(datum=NA) +
#   theme_minimal() +
#   theme_bw()

```

More complex models with random effects and multiple smooths are also possible with `mgcv` and the `st_augment()` and `st_quickmap_preds()` functions can handle these and label the columns and maps which are generated appropriately. This is shown below with a model of swing in the 2019 election:

```{r, fig.width=12, fig.height=6}

prep_data3 <- st_bridges(df_scaled_sf, "constituency_name") # decide upon the contiguities and add them to the df

model <- gam(con_swing ~ 
               s(region, bs="re") + # region level random intercept
               s(county, bs="re") + # county level random intercept
               s(county, degree_educated, bs="re") + # county level random coefficient
               s(constituency_name, bs='mrf', 
                 xt=list(nb=prep_data3$nb),k=10) + # ICAR constituency ICAR varying coefficients
               s(constituency_name, by=white, bs='mrf', 
                 xt=list(nb=prep_data3$nb),k=10), # ICAR constituency ICAR varying coefficients
             data=prep_data3, method="REML") |> 
  st_augment(prep_data3) |> # pipe into function to get estimates
  st_quickmap_preds() # pipe into this for visualisation

ggarrange(plotlist = model, legend = "none", nrow=1)
```

To see the estimates returned:

```{r}

gam(con_swing ~ 
               s(region, bs="re") + # region level random intercept
               s(county, bs="re") + # county level random intercept
               s(county, degree_educated, bs="re") + # county level random coefficient
               s(constituency_name, bs='mrf', 
                 xt=list(nb=prep_data3$nb),k=10) + # ICAR constituency ICAR varying coefficients
               s(constituency_name, by=white, bs='mrf', 
                 xt=list(nb=prep_data3$nb),k=10), # ICAR constituency ICAR varying coefficients
             data=prep_data3, method="REML") |> 
  st_augment(prep_data3) |> 
  head()

```

### Back to the `guerry` dataset

Returning to the dataset used in `sfdep`, we can easily create a smooth of suicides in France in 1830 as follows. Since there are no islands, we use `st_bridges()` and it will function like `sfdep:st_contiguity()` except that it automatically adds a neighbourhood 'nb' column to the dataframe.

```{r}
prep_data4 <- g |> st_bridges("department")

mod4 <- gam(suicides ~ s(department, bs='mrf', xt=list(nb=prep_data4$nb), k=80),
            data=prep_data4, method="REML") |>
  st_augment(prep_data4) |>
  st_quickmap_preds()
ggarrange(plotlist=mod4)

```

Or fit a more complex mixed model:

```{r, fig.width=12, fig.height=6}
prep_data5 <- g |> 
  st_bridges("department")

model5 <- gam(donations ~ 
                s(region, bs="re") + 
                s(region, crime_prop, bs="re") + # county level random coefficient
                s(department, bs='mrf', 
                  xt=list(nb=prep_data5$nb),k=20) + # ICAR constituency level varying coefficents
                s(department, by=infants, bs='mrf', 
                  xt=list(nb=prep_data5$nb),k=20), # ICAR constituency level varying coefficents
              data=prep_data5, method="REML") |> 
  st_augment(prep_data5) |> # pipe into function to get estimates
  st_quickmap_preds() # pipe into this for visualisation

ggarrange(plotlist = model5, legend = "none", nrow = 1)
```
